#ifndef REGIONDATA_H_
#define REGIONDATA_H_

#include <iostream>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <utility>
#include <cstddef>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/path.hpp>
#include <fstream>
#include <boost/filesystem.hpp>

using namespace std;
namespace fs = boost::filesystem;

class RegionData 
{

public:
  // Member functions
  RegionData() : ori_image(),ori_map(),image(), map(), xRes(1.0), yRes(1.0), \
      transform(cv::getRotationMatrix2D(cv::Point2f(0,0), 0, 1.0)), \
      invertTransform(cv::getRotationMatrix2D(cv::Point2f(0,0), 0, 1.0)), \
      hasRotated(false), \
      topLeftWorldLatitude(INVALID_DEGREE_VALUE), \
      topLeftWorldLongitude(INVALID_DEGREE_VALUE) 
  {
  };

  // This function loads the raw world image (i.e. Satellite view), the
  // binary world map (i.e. for computing the BCD), and auxiliary GCS
  // information
  //
  // E.g.: loadWorld("./image.png") assumes the following files exist:
  // - "./image.png": raw world image
  // - "./image.map.png": binary world map
  // - "./image.wf": world file, generated by Procerus MapMaker
  void loadWorld(std::string filename) throw (const std::string&);

  // Loads latitude and longitude data from .wf file
  void parseWorldFile(std::string filename) throw (const std::string&);

  bool empty();

  cv::Mat rotateImage(const cv::Mat& source, double angle, \
      cv::Point2f src_center);

  cv::Mat rotateImage(const cv::Mat& source, const cv::Mat& newTransform, \
      double width, double height);

  std::pair<double, cv::Point2f> computeAlignmentToObstacles();

  std::pair<double, cv::Point2f> computeAlignmentToFreespace();

  // Utility macro to rotate both the world and the map
  // NOTE: angle is in degrees, IN RIGHT HAND COORD SYSTEM!!!
  inline void rotateAllData(double angle, cv::Point2f src_center) {
    image = rotateImage(ori_image, angle, src_center);
    map = rotateImage(ori_map, angle, src_center);
  };
  inline void rotateAllData(double angle) {
    rotateAllData(angle, cv::Point2f(ori_image.cols/2.0, ori_image.rows/2.0));
  };
  inline void rotateAllData(std::pair<double, cv::Point2f> angle_ctr) {
    rotateAllData(angle_ctr.first, angle_ctr.second);
  };
  inline void rotateAllData(const cv::Mat& newTransform, double width, \
      double height) {
    image = rotateImage(ori_image, newTransform, width, height);
    map = rotateImage(ori_map, newTransform, width, height);
  };

  std::pair<double, double> transformPoint(double xPixel, double yPixel) {
    double *data = (double*) transform.data;
    return std::make_pair(xPixel*data[0] + yPixel*data[1] + data[2], \
        xPixel*data[3] + yPixel*data[4] + data[5]);
  };
  std::pair<double, double> invertTransformPoint(double xPixel, double yPixel) {
    double *data = (double*) invertTransform.data;
    return std::make_pair(xPixel*data[0] + yPixel*data[1] + data[2], \
        xPixel*data[3] + yPixel*data[4] + data[5]);
  };

  // Same as transformPoint, except does not shift by offsets
  std::pair<double, double> rotateVector(double xPixel, double yPixel) {
    double *data = (double*) transform.data;
    return std::make_pair(xPixel*data[0] + yPixel*data[1], \
        xPixel*data[3] + yPixel*data[4]);
  };
  std::pair<double, double> invertRotateVector(double xPixel, double yPixel) {
    double *data = (double*) invertTransform.data;
    return std::make_pair(xPixel*data[0] + yPixel*data[1], \
        xPixel*data[3] + yPixel*data[4]);
  };

  void clear() 
  {
    ori_image = cv::Mat();
    ori_map = cv::Mat();
    image = cv::Mat();
    map = cv::Mat();

    xRes = 1.0;
    yRes = 1.0;
    transform = cv::getRotationMatrix2D(cv::Point2f(0,0), 0, 1.0);
    invertTransform = cv::getRotationMatrix2D(cv::Point2f(0,0), 0, 1.0);
    hasRotated = false;
  };

  // Static functions
  static bool solveQuadraticEquation(double A,double B,double C,double &r1, \
      double &r2);

  cv::Mat getImage();
  cv::Mat getMap();
  cv::Mat getOriginalImage();
  cv::Mat getOriginalMap();

  // Member fields
  cv::Mat ori_image;
  cv::Mat ori_map;
  cv::Mat image; // raw world image
  cv::Mat map; // black = obstacle, white = free space
  double xRes; // units: meter / pixel
  double yRes; // units: meter / pixel
  cv::Mat transform;
  cv::Mat invertTransform; // to get the original pixel location, use this.
  bool hasRotated;
  std::string loadWorldFilename;

  // Constants
  const static unsigned char BLACK = 0;
  const static unsigned char WHITE = 255;

  double topLeftWorldLatitude;
  double topLeftWorldLongitude;

  const static float INVALID_DEGREE_VALUE = 361.0;
};


#endif /* REGIONDATA_H_ */
